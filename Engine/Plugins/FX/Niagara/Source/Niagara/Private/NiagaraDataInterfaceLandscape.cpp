// Copyright Epic Games, Inc. All Rights Reserved.

#include "NiagaraDataInterfaceLandscape.h"

#include "EngineUtils.h"
#include "Landscape.h"
#include "LandscapeHeightfieldCollisionComponent.h"
#include "LandscapeInfo.h"
#include "LandscapeInfoMap.h"
#include "LandscapeProxy.h"
#include "NiagaraComponent.h"
#include "NiagaraCustomVersion.h"
#include "NiagaraShader.h"
#include "NiagaraStats.h"
#include "NiagaraWorldManager.h"
#include "PhysicalMaterials/PhysicalMaterial.h"
#include "ShaderParameterUtils.h"
#include "VT/RuntimeVirtualTexture.h"

#define LOCTEXT_NAMESPACE "UNiagaraDataInterfaceLandscape"

//////////////////////////////////////////////////////////////////////////
// remaining features
// -getting the surface normal at a point
// -getting the physical material at a point
// -getting the albedo colour at a point
// -support for CPU

class FNDI_Landscape_SharedResource;
struct FNDILandscapeData_GameThread;

namespace NiagaraDataInterfaceLandscape
{
	enum Version
	{
		InitialVersion = 0,
		SupportVirtualTextures = 1,

		VersionPlusOne,
		LatestVersion = VersionPlusOne - 1
	};
}

const FName UNiagaraDataInterfaceLandscape::GetHeightName(TEXT("GetHeight"));
const FName UNiagaraDataInterfaceLandscape::GetWorldNormalName(TEXT("GetWorldNormal"));
const FName UNiagaraDataInterfaceLandscape::GetPhysicalMaterialIndexName(TEXT("GetPhysicalMaterialIndex"));

// RenderResource used to hold textures generated by this DI, pulled from the collision geometry of the terrain
class FLandscapeTextureResource : public FRenderResource
{
public:
	FLandscapeTextureResource(FNDI_Landscape_SharedResource& InOwner);
	virtual ~FLandscapeTextureResource() = default;

	FLandscapeTextureResource() = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&) = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&&) = delete;

	virtual void InitRHI() override;
	virtual void ReleaseRHI() override;

	FRHIShaderResourceView* GetHeightTexture() const { return HeightTexture.SRV; }
	FRHIShaderResourceView* GetPhysMatTexture() const { return PhysMatTexture.SRV; }
	FIntPoint GetPhysMatDimensions() const { return PhysMatDimensions; }

private:
	FNDI_Landscape_SharedResource& Owner;

	FTextureReadBuffer2D HeightTexture;
	FTextureReadBuffer2D PhysMatTexture;
	FIntPoint PhysMatDimensions;

#if STATS
	int32 GpuMemoryUsage = 0;
#endif
};

// SharedResource that can be held by multiple system instances which manages the resources created by this DI
class FNDI_Landscape_SharedResource
{
public:
	struct FResourceKey
	{
		TWeakObjectPtr<const ALandscape> Source = nullptr;
		TArray<TWeakObjectPtr<const UPhysicalMaterial>> PhysicalMaterials;
		TArray<FIntPoint> CapturedRegions;
		FIntPoint MinCaptureRegion = FIntPoint(ForceInitToZero);
		FIntPoint MaxCaptureRegion = FIntPoint(ForceInitToZero);
		bool IncludesCachedHeight = false;
		bool IncludesCachedPhysMat = false;
	};

	struct FTextureBulkData : public FResourceBulkDataInterface
	{
		FTextureBulkData(const void* InData, uint32 InDataSize) : Data(InData), DataSize(InDataSize) {}
		virtual const void* GetResourceBulkData() const override { return Data; }
		virtual uint32 GetResourceBulkDataSize() const override { return DataSize; }
		virtual void Discard() override { }
		const void* Data = nullptr;
		uint32 DataSize = 0;
	};

	FNDI_Landscape_SharedResource() = delete;
	FNDI_Landscape_SharedResource(const FNDI_Landscape_SharedResource&) = delete;
	FNDI_Landscape_SharedResource(const FResourceKey& InKey);

	bool IsUsed() const;
	bool CanBeDestroyed() const;
	bool CanRepresent(const FResourceKey& InKey) const;
	bool RequiresInit() const;

	void RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately);
	void UnregisterUser(const FNDI_SharedResourceUsage& Usage);

	void Initialize();

	FTextureBulkData GetHeightBulkData() { return FTextureBulkData(HeightValues.GetData(), HeightValues.Num() * HeightValues.GetTypeSize()); }
	FTextureBulkData GetPhysMatBulkData() { return FTextureBulkData(PhysMatValues.GetData(), PhysMatValues.Num() * PhysMatValues.GetTypeSize()); }

	FLandscapeTextureResource LandscapeTextures;
	FMatrix ActorToWorldTransform = FMatrix::Identity;
	FMatrix WorldToActorTransform = FMatrix::Identity;
	FVector4 UvScaleBias = FVector4(1.0f, 1.0f, 0.0f, 0.0f);
	FIntPoint CellCount = FIntPoint(ForceInitToZero);
	FVector2D TextureWorldGridSize = FVector2D(1.0f, 1.0f);

private:
	void ReleaseCpu();
	void ReleaseGpu();

	FResourceKey ResourceKey;

	std::atomic<int32> CachedCpuPhysicsDataUserCount{ 0 };
	std::atomic<int32> CachedGpuPhysicsDataUserCount{ 0 };

	TArray<float> HeightValues;
	TArray<uint8> PhysMatValues;

	FThreadSafeBool GpuDataReleasedByRt = false;
	FThreadSafeBool CpuDataReleasedByRt = false;
	bool GpuDataQueuedForRelease = false;
	bool CpuDataQueuedForRelease = false;

	bool RequiresCpuInit = false;
	bool RequiresGpuInit = false;
};

using FNDI_Landscape_SharedResourceHandle = FNDI_SharedResourceHandle<FNDI_Landscape_SharedResource, FNDI_SharedResourceUsage>;

// Landscape data used for the game thread
struct FNDILandscapeData_GameThread
{
	TWeakObjectPtr<ALandscape> Landscape;
	FNDI_Landscape_SharedResourceHandle SharedResourceHandle;
	int32 HeightVirtualTextureIndex = INDEX_NONE;
	int32 NormalVirtualTextureIndex = INDEX_NONE;
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
	bool RequiresCollisionCacheCpu = false;
	bool RequiresCollisionCacheGpu = false;
	bool RequiresPhysMatCacheGpu = false;

	void Reset()
	{
		Landscape = nullptr;
		SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		HeightVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
		RequiresCollisionCacheCpu = false;
		RequiresCollisionCacheGpu = false;
		RequiresPhysMatCacheGpu = false;
	}
};

// Landscape data used on the render thread
struct FNDILandscapeData_RenderThread
{
	const URuntimeVirtualTexture* HeightVirtualTexture = nullptr;
	const URuntimeVirtualTexture* NormalVirtualTexture = nullptr;
	const FLandscapeTextureResource* TextureResources = nullptr;
	FVector4 HeightVirtualTextureWorldToUvParameters[4];
	FVector4 NormalVirtualTextureWorldToUvParameters[3];
	FMatrix CachedHeightTextureWorldToUvTransform = FMatrix::Identity;
	FMatrix CachedHeightTextureUvToWorldTransform = FMatrix::Identity;
	FVector4 CachedHeightTextureUvScaleBias = FVector4(ForceInitToZero);
	FVector2D CachedHeightTextureGridSize = FVector2D(1.0f, 1.0f);
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
};

class FNDI_Landscape_GeneratedData : public FNDI_GeneratedData
{
public:
	virtual void Tick(ETickingGroup TickGroup, float DeltaSeconds) override;

	static TypeHash GetTypeHash();

	FNDI_Landscape_SharedResourceHandle GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately);

private:
	FRWLock LandscapeDataGuard;
	TArray<TSharedPtr<FNDI_Landscape_SharedResource>> LandscapeData;
};

struct FNiagaraDataInterfaceProxyLandscape : public FNiagaraDataInterfaceProxy
{
	virtual void ConsumePerInstanceDataFromGameThread(void* PerInstanceData, const FNiagaraSystemInstanceID& Instance) override
	{
		const FNDILandscapeData_RenderThread& SourceData = *reinterpret_cast<const FNDILandscapeData_RenderThread*>(PerInstanceData);
		*SystemInstancesToProxyData_RT.Find(Instance) = SourceData;
	}

	virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
	{
		return sizeof(FNDILandscapeData_RenderThread);
	}

	TMap<FNiagaraSystemInstanceID, FNDILandscapeData_RenderThread> SystemInstancesToProxyData_RT;
};

FLandscapeTextureResource::FLandscapeTextureResource(FNDI_Landscape_SharedResource& InOwner)
: Owner(InOwner)
{

}

void FLandscapeTextureResource::InitRHI()
{
	auto HeightBulkData = Owner.GetHeightBulkData();
	if (HeightBulkData.DataSize)
	{
		FRHIResourceCreateInfo CreateInfo;
		CreateInfo.BulkData = &HeightBulkData;
		CreateInfo.DebugName = TEXT("NiagaraLandscapeCachedHeight");
		HeightTexture.Initialize(sizeof(float), Owner.CellCount.X, Owner.CellCount.Y, EPixelFormat::PF_R32_FLOAT, FTextureReadBuffer2D::DefaultTextureInitFlag, CreateInfo);
	}

	auto PhysMatBulkData = Owner.GetPhysMatBulkData();
	if (PhysMatBulkData.DataSize)
	{
		FRHIResourceCreateInfo CreateInfo;
		CreateInfo.BulkData = &PhysMatBulkData;
		CreateInfo.DebugName = TEXT("NiagaraLandscapeCachedPhysMat");
		PhysMatTexture.Initialize(sizeof(uint8), Owner.CellCount.X, Owner.CellCount.Y, EPixelFormat::PF_R8_UINT, FTextureReadBuffer2D::DefaultTextureInitFlag, CreateInfo);

		PhysMatDimensions = FIntPoint(Owner.CellCount.X, Owner.CellCount.Y);
	}

#if STATS
	check(GpuMemoryUsage == 0);
	GpuMemoryUsage = HeightTexture.NumBytes + PhysMatTexture.NumBytes;
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
#endif
}

void FLandscapeTextureResource::ReleaseRHI()
{
	HeightTexture.Release();
	PhysMatTexture.Release();

#if STATS
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
	GpuMemoryUsage = 0;
#endif
}

FNDI_Landscape_SharedResource::FNDI_Landscape_SharedResource(const FResourceKey& InKey)
: LandscapeTextures(*this)
, ResourceKey(InKey)
{
}

bool FNDI_Landscape_SharedResource::IsUsed() const
{
	return (CachedCpuPhysicsDataUserCount > 0)
		|| (CachedGpuPhysicsDataUserCount > 0);
}

bool FNDI_Landscape_SharedResource::CanBeDestroyed() const
{
	const bool ReadyForRemoval = !IsUsed() && GpuDataReleasedByRt && CpuDataReleasedByRt;

	checkf(!ReadyForRemoval || !LandscapeTextures.IsInitialized(),
		TEXT("FNDI_Landscape_SharedResource::CanBeDestroyed returning true, but the LandscpaeTextures is still initialized! Source[%s] MinRegion[%d,%d] MaxRegion[%d,%d]"),
		*GetNameSafe(ResourceKey.Source.Get()), ResourceKey.MinCaptureRegion.X, ResourceKey.MinCaptureRegion.Y, ResourceKey.MaxCaptureRegion.X, ResourceKey.MaxCaptureRegion.Y);

	return ReadyForRemoval;
}

bool FNDI_Landscape_SharedResource::CanRepresent(const FResourceKey& RequestKey) const
{
	// once data has been queued for release make sure we don't try to re-use it.  CpuData can be released
	// since it's currently just an intermediary for the Gpu data
	if (GpuDataQueuedForRelease)
	{
		return false;
	}

	if (ResourceKey.Source != RequestKey.Source)
	{
		return false;
	}

	if ((RequestKey.IncludesCachedHeight && !ResourceKey.IncludesCachedHeight)
		|| (RequestKey.IncludesCachedPhysMat && !ResourceKey.IncludesCachedPhysMat))
	{
		return false;
	}

	if (ResourceKey.MinCaptureRegion.X > RequestKey.MinCaptureRegion.X
		|| ResourceKey.MaxCaptureRegion.X < RequestKey.MaxCaptureRegion.X
		|| ResourceKey.MinCaptureRegion.Y > RequestKey.MinCaptureRegion.Y
		|| ResourceKey.MaxCaptureRegion.Y < RequestKey.MaxCaptureRegion.Y)
	{
		return false;
	}

	if (ResourceKey.PhysicalMaterials.Num() < RequestKey.PhysicalMaterials.Num())
	{
		return false;
	}

	for (int32 MaterialIt = 0; MaterialIt < RequestKey.PhysicalMaterials.Num(); ++MaterialIt)
	{
		if (ResourceKey.PhysicalMaterials[MaterialIt] != RequestKey.PhysicalMaterials[MaterialIt])
		{
			return false;
		}
	}

	const int32 CapturedRegionCount = ResourceKey.CapturedRegions.Num();
	int32 SearchIndex = 0;
	for (const FIntPoint& RequestRegion : RequestKey.CapturedRegions)
	{
		while (SearchIndex < CapturedRegionCount && ResourceKey.CapturedRegions[SearchIndex] != RequestRegion)
		{
			++SearchIndex;
		}
	}

	return SearchIndex < CapturedRegionCount;
}

bool FNDI_Landscape_SharedResource::RequiresInit() const
{
	return RequiresCpuInit || RequiresGpuInit;
}

void FNDI_Landscape_SharedResource::RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately)
{
	if (Usage.RequiresCpuAccess)
	{
		if (CachedCpuPhysicsDataUserCount++ == 0)
		{
			RequiresCpuInit = true;
		}
	}

	if (Usage.RequiresGpuAccess)
	{
		if (CachedGpuPhysicsDataUserCount++ == 0)
		{
			RequiresGpuInit = true;
		}
	}
}

void FNDI_Landscape_SharedResource::UnregisterUser(const FNDI_SharedResourceUsage& Usage)
{
	if (Usage.RequiresCpuAccess)
	{
		if (--CachedCpuPhysicsDataUserCount == 0)
		{
			ReleaseCpu();
		}
	}

	if (Usage.RequiresGpuAccess)
	{
		if (--CachedGpuPhysicsDataUserCount == 0)
		{
			ReleaseGpu();
		}
	}
}

void FNDI_Landscape_SharedResource::Initialize()
{
	if (RequiresInit())
	{
		if (const ULandscapeInfo* LandscapeInfo = ResourceKey.Source->GetLandscapeInfo())
		{
			const int32 ComponentQuadCount = ResourceKey.Source->ComponentSizeQuads;
			const FIntPoint RegionSpan = ResourceKey.MaxCaptureRegion - ResourceKey.MinCaptureRegion + FIntPoint(1, 1);
			const FIntPoint CaptureQuadSpan = RegionSpan * ComponentQuadCount;
			const FIntPoint CaptureVertexSpan = CaptureQuadSpan + FIntPoint(1, 1);
			const int32 SampleCount = CaptureVertexSpan.X * CaptureVertexSpan.Y;

			if (ResourceKey.IncludesCachedHeight)
			{
				const float DefaultHeight = 0.0f;
				HeightValues.Reset(SampleCount);
				HeightValues.Init(DefaultHeight, SampleCount);
			}

			if (ResourceKey.IncludesCachedPhysMat)
			{
				const uint8 DefaultPhysMat = INDEX_NONE;
				PhysMatValues.Reset(SampleCount);
				PhysMatValues.Init(DefaultPhysMat, SampleCount);
			}

			const FIntPoint RegionVertexBase = ResourceKey.MinCaptureRegion * ComponentQuadCount;

			for (const FIntPoint& Region : ResourceKey.CapturedRegions)
			{
				auto FoundCollisionComponent = LandscapeInfo->XYtoCollisionComponentMap.Find(Region);
				check(FoundCollisionComponent);

				if (FoundCollisionComponent)
				{
					if (const ULandscapeHeightfieldCollisionComponent* CollisionComponent = *FoundCollisionComponent)
					{
						if (ResourceKey.IncludesCachedHeight)
						{
							const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
							CollisionComponent->FillHeightTile(HeightValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);
						}

						if (ResourceKey.IncludesCachedPhysMat)
						{
							const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
							CollisionComponent->FillMaterialIndexTile(PhysMatValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);

							// remap the material index to the list we have on the DI
							TArray<uint8> PhysMatRemap;
							for (const UPhysicalMaterial* ComponentMaterial : CollisionComponent->CookedPhysicalMaterials)
							{
								PhysMatRemap.Emplace(ResourceKey.PhysicalMaterials.IndexOfByKey(ComponentMaterial));
							}

							for (int32 Y = 0; Y < ComponentQuadCount; ++Y)
							{
								for (int32 X = 0; X < ComponentQuadCount; ++X)
								{
									const int32 WriteIndex = SectionBase.X + X + (SectionBase.Y + Y) * CaptureVertexSpan.X;
									uint8& PhysMatIndex = PhysMatValues[WriteIndex];
									PhysMatIndex = PhysMatRemap.IsValidIndex(PhysMatIndex) ? PhysMatRemap[PhysMatIndex] : INDEX_NONE;
								}
							}
						}
					}
				}
			}

			// number of cells that are represented in our heights array
			CellCount = CaptureVertexSpan;

			// mapping to get the UV from 'cell space' which is relative to the entire terrain (not just the captured regions)
			FVector2D UvScale(1.0f / CaptureVertexSpan.X, 1.0f / CaptureVertexSpan.Y);

			UvScaleBias = FVector4(
				UvScale.X,
				UvScale.Y,
				(0.5f - RegionVertexBase.X) * UvScale.X,
				(0.5f - RegionVertexBase.Y) * UvScale.Y);

			ActorToWorldTransform = ResourceKey.Source->GetTransform().ToMatrixWithScale();
			WorldToActorTransform = ActorToWorldTransform.Inverse();
			TextureWorldGridSize = FVector2D(ResourceKey.Source->GetTransform().GetScale3D());

			if (RequiresGpuInit)
			{
				BeginInitResource(&LandscapeTextures);

				if (!RequiresCpuInit)
				{
					// if we're only using the GPU copy of the resource, then we can clear our CPU copy (when the render thread is done
					// with using it to initialize the textures)
					FNDI_Landscape_SharedResource* ThisResource = this;
					CpuDataQueuedForRelease = true;
					CpuDataReleasedByRt = false;
					FThreadSafeBool* Released = &CpuDataReleasedByRt;

					ENQUEUE_RENDER_COMMAND(ReleaseCpuArray)(
						[ThisResource, Released](FRHICommandListImmediate& RhiCmdList)
					{
						ThisResource->ReleaseCpu();
						*Released = true;
					});
				}
			}

			RequiresCpuInit = false;
			RequiresGpuInit = false;
		}
	}
}

void FNDI_Landscape_SharedResource::ReleaseCpu()
{
	HeightValues.Empty(0);
	PhysMatValues.Empty(0);
}

void FNDI_Landscape_SharedResource::ReleaseGpu()
{
	GpuDataQueuedForRelease = true;
	GpuDataReleasedByRt = false;
	FThreadSafeBool* Released = &GpuDataReleasedByRt;

	BeginReleaseResource(&LandscapeTextures);

	ENQUEUE_RENDER_COMMAND(BeginDestroyCommand)(
		[Released](FRHICommandListImmediate& RHICmdList)
	{
		*Released = true;
	});
}

void FNDI_Landscape_GeneratedData::Tick(ETickingGroup TickGroup, float DeltaSeconds)
{
	{ // handle any changes to the UV mappings
		FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

		TArray<int32, TInlineAllocator<32>> LandscapeToRemove;

		const int32 LandscapeCount = LandscapeData.Num();

		for (int32 LandscapeIt = 0; LandscapeIt < LandscapeCount; ++LandscapeIt)
		{
			const TSharedPtr<FNDI_Landscape_SharedResource>& Landscape = LandscapeData[LandscapeIt];

			if (Landscape->CanBeDestroyed())
			{
				LandscapeToRemove.Add(LandscapeIt);
			}
		}

		while (LandscapeToRemove.Num())
		{
			LandscapeData.RemoveAtSwap(LandscapeToRemove.Pop(false));
		}
	}

	// go through any resources and see if they need/can be initialized
	{
		FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

		for (auto Resource : LandscapeData)
		{
			if (Resource->RequiresInit())
			{
				Resource->Initialize();
			}
		}
	}
}

FNDI_GeneratedData::TypeHash FNDI_Landscape_GeneratedData::GetTypeHash()
{
	static const TypeHash Hash = ::GetTypeHash(TEXT("FNDI_Landscape_GeneratedData"));
	return Hash;
}

FNDI_Landscape_SharedResourceHandle FNDI_Landscape_GeneratedData::GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately)
{
	const ALandscape* Landscape = InstanceData.Landscape.Get();
	const ULandscapeInfo* LandscapeInfo = Landscape ? Landscape->GetLandscapeInfo() : nullptr;

	if (LandscapeInfo == nullptr)
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// we want to use the bounds of the system to figure out which cells of the landscape that we need to handle
	const FBox SystemWorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());
	const FTransform& LandscapeActorToWorld = Landscape->LandscapeActorToWorld();
	const FVector SystemMinInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Min);
	const FVector SystemMaxInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Max);

	const FBox SystemBoundsInLandscape(
		SystemMinInLandscape.ComponentMin(SystemMaxInLandscape),
		SystemMinInLandscape.ComponentMax(SystemMaxInLandscape));

	// at runtime we don't know the potential number of components in the landscape, so we can only clamp the values to start at 0.
	// Ideally, we'd be able to specify an upper bound as well to further refine the region of overlap.
	const FIntPoint MinBoundRegion = FIntPoint(SystemBoundsInLandscape.Min.X, SystemBoundsInLandscape.Min.Y).ComponentMax(FIntPoint(0, 0));
	const FIntPoint MaxBoundRegion = FIntPoint(SystemBoundsInLandscape.Max.X, SystemBoundsInLandscape.Max.Y).ComponentMax(FIntPoint(0, 0));

	const FIntRect SystemRect = FIntRect(MinBoundRegion, MaxBoundRegion).Scale(1.0f / Landscape->ComponentSizeQuads);

	FNDI_Landscape_SharedResource::FResourceKey Key;
	Key.Source = Landscape;
	Key.MinCaptureRegion = FIntPoint(TNumericLimits<int32>::Max(), TNumericLimits<int32>::Max());
	Key.MaxCaptureRegion = FIntPoint(TNumericLimits<int32>::Min(), TNumericLimits<int32>::Min());

	const int32 MaxSystemRegionCount = (SystemRect.Max.X - SystemRect.Min.X) * (SystemRect.Max.Y - SystemRect.Min.Y);
	const int32 MaxLandscapeRegionCount = LandscapeInfo->XYtoCollisionComponentMap.Num();

	Key.IncludesCachedHeight = InstanceData.RequiresCollisionCacheGpu;
	Key.IncludesCachedPhysMat = InstanceData.RequiresPhysMatCacheGpu;
	Key.PhysicalMaterials.Reserve(LandscapeDI.PhysicalMaterials.Num());
	for (const UPhysicalMaterial* Material : LandscapeDI.PhysicalMaterials)
	{
		Key.PhysicalMaterials.Emplace(Material);
	}

	auto AddRegion = [&](const FIntPoint& Region)
	{
		Key.CapturedRegions.Add(Region);
		Key.MinCaptureRegion = Key.MinCaptureRegion.ComponentMin(Region);
		Key.MaxCaptureRegion = Key.MaxCaptureRegion.ComponentMax(Region);
	};

	if (MaxSystemRegionCount > MaxLandscapeRegionCount)
	{
		Key.CapturedRegions.Reserve(MaxLandscapeRegionCount);

		for (const auto& LandscapeComponent : LandscapeInfo->XYtoCollisionComponentMap)
		{
			if (SystemRect.Contains(LandscapeComponent.Key))
			{
				AddRegion(LandscapeComponent.Key);
			}
		}
	}
	else
	{
		Key.CapturedRegions.Reserve(MaxSystemRegionCount);

		for (int32 GridY = SystemRect.Min.Y; GridY < SystemRect.Max.Y; ++GridY)
		{
			for (int32 GridX = SystemRect.Min.X; GridX < SystemRect.Max.X; ++GridX)
			{
				const FIntPoint CurrentRegion(GridX, GridY);
				if (LandscapeInfo->XYtoCollisionComponentMap.Contains(CurrentRegion))
				{
					AddRegion(CurrentRegion);
				}
			}
		}
	}

	if (!Key.CapturedRegions.Num())
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// Attempt to Find data
	{
		FRWScopeLock ReadLock(LandscapeDataGuard, SLT_ReadOnly);
		TSharedPtr<FNDI_Landscape_SharedResource>* Existing = LandscapeData.FindByPredicate([&](const TSharedPtr<FNDI_Landscape_SharedResource>& LandscapeEntry)
		{
			return LandscapeEntry->CanRepresent(Key);
		});

		if (Existing)
		{
			return FNDI_Landscape_SharedResourceHandle(Usage, *Existing, bNeedsDataImmediately);
		}
	}

	// We need to add
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);
	return FNDI_Landscape_SharedResourceHandle(
		Usage,
		LandscapeData.Add_GetRef(MakeShared<FNDI_Landscape_SharedResource>(Key)),
		bNeedsDataImmediately);
}

UNiagaraDataInterfaceLandscape::UNiagaraDataInterfaceLandscape(FObjectInitializer const& ObjectInitializer)
	: Super(ObjectInitializer)		
{
	Proxy.Reset(new FNiagaraDataInterfaceProxyLandscape());
}

void UNiagaraDataInterfaceLandscape::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject))
	{
		ENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;
		FNiagaraTypeRegistry::Register(FNiagaraTypeDefinition(GetClass()), Flags);
	}	
}

bool UNiagaraDataInterfaceLandscape::CopyToInternal(UNiagaraDataInterface* Destination) const
{
	if (!Super::CopyToInternal(Destination))
	{
		return false;
	}
	UNiagaraDataInterfaceLandscape* DestinationLandscape = CastChecked<UNiagaraDataInterfaceLandscape>(Destination);
	DestinationLandscape->SourceLandscape = SourceLandscape;	
	DestinationLandscape->SourceMode = SourceMode;
	DestinationLandscape->PhysicalMaterials = PhysicalMaterials;

	return true;
}

bool UNiagaraDataInterfaceLandscape::Equals(const UNiagaraDataInterface* Other) const
{
	if (!Super::Equals(Other))
	{
		return false;
	}
	const UNiagaraDataInterfaceLandscape* OtherLandscape = CastChecked<const UNiagaraDataInterfaceLandscape>(Other);
	return OtherLandscape->SourceLandscape == SourceLandscape
		&& OtherLandscape->SourceMode == SourceMode
		&& OtherLandscape->PhysicalMaterials == PhysicalMaterials;
}

void UNiagaraDataInterfaceLandscape::GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions)
{
	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetHeightName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("WorldPos")));		
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetFloatDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetWorldNormalName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetPhysicalMaterialIndexName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

#if WITH_EDITORONLY_DATA
	for (FNiagaraFunctionSignature& Sig : OutFunctions)
	{
		Sig.FunctionVersion = NiagaraDataInterfaceLandscape::LatestVersion;
	}
#endif
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::UpgradeFunctionCall(FNiagaraFunctionSignature& FunctionSignature)
{
	bool WasChanged = false;

	if (FunctionSignature.FunctionVersion < NiagaraDataInterfaceLandscape::SupportVirtualTextures)
	{
		if (FunctionSignature.Name == GetHeightName)
		{
			FunctionSignature.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));
			WasChanged = true;
		}
	}

	FunctionSignature.FunctionVersion = NiagaraDataInterfaceLandscape::LatestVersion;
	return WasChanged;
}
#endif

void UNiagaraDataInterfaceLandscape::ProvidePerInstanceDataForRenderThread(void* DataForRenderThread, void* PerInstanceData, const FNiagaraSystemInstanceID& SystemInstance)
{
	const FNDILandscapeData_GameThread& SourceData = *reinterpret_cast<const FNDILandscapeData_GameThread*>(PerInstanceData);
	FNDILandscapeData_RenderThread* TargetData = new(DataForRenderThread) FNDILandscapeData_RenderThread();

	if (SourceData.SharedResourceHandle)
	{
		const FNDI_Landscape_SharedResource& SourceResource = SourceData.SharedResourceHandle.ReadResource();

		TargetData->TextureResources = &SourceResource.LandscapeTextures;
		
		TargetData->CachedHeightTextureUvScaleBias = SourceResource.UvScaleBias;
		TargetData->CachedHeightTextureWorldToUvTransform = SourceResource.WorldToActorTransform;
		TargetData->CachedHeightTextureUvToWorldTransform = SourceResource.ActorToWorldTransform;
		TargetData->CachedHeightTextureGridSize = SourceResource.TextureWorldGridSize;
	}

	if (SourceData.HeightVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.HeightVirtualTextureIndex])
		{
			TargetData->HeightVirtualTexture = VirtualTexture;
			TargetData->HeightVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->HeightVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->HeightVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->HeightVirtualTextureWorldToUvParameters[3] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldHeightUnpack);
		}
	}

	if (SourceData.NormalVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.NormalVirtualTextureIndex])
		{
			TargetData->NormalVirtualTexture = VirtualTexture;
			TargetData->NormalVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->NormalVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->NormalVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->NormalVirtualTextureMode = SourceData.NormalVirtualTextureMode;
		}
	}
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::AppendCompileHash(FNiagaraCompileHashVisitor* InVisitor) const
{
	if (!Super::AppendCompileHash(InVisitor))
	{
		return false;
	}

	FSHAHash Hash = GetShaderFileHash((TEXT("/Plugin/FX/Niagara/Private/NiagaraDataInterfaceLandscape.ush")), EShaderPlatform::SP_PCD3D_SM5);
	InVisitor->UpdateString(TEXT("NiagaraDataInterfaceLandscapeHLSLSource"), Hash.ToString());

	return true;

}

void UNiagaraDataInterfaceLandscape::GetCommonHLSL(FString& OutHLSL)
{
	OutHLSL += TEXT("#include \"/Plugin/FX/Niagara/Private/NiagaraDataInterfaceLandscape.ush\"\n");
}

void UNiagaraDataInterfaceLandscape::GetParameterDefinitionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, FString& OutHLSL)
{
	Super::GetParameterDefinitionHLSL(ParamInfo, OutHLSL);

	OutHLSL += TEXT("NDILANDSCAPE_DECLARE_CONSTANTS(") + ParamInfo.DataInterfaceHLSLSymbol + TEXT(")\n");
}

bool UNiagaraDataInterfaceLandscape::GetFunctionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo, int FunctionInstanceIndex, FString& OutHLSL)
{
	TMap<FString, FStringFormatArg> ArgsSample =
	{
		{TEXT("InstanceFunctionName"), FunctionInfo.InstanceName},
		{TEXT("NDIGetContextName"), TEXT("NDILANDSCAPE_MAKE_CONTEXT(") + ParamInfo.DataInterfaceHLSLSymbol + TEXT(")")},
	};

	if (FunctionInfo.DefinitionName == GetHeightName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out float OutHeight, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetHeight(DIContext, InWorldPos, OutHeight, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}
	else if (FunctionInfo.DefinitionName == GetWorldNormalName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out float3 OutWorldNormal, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetWorldNormal(DIContext, InWorldPos, OutWorldNormal, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}
	else if (FunctionInfo.DefinitionName == GetPhysicalMaterialIndexName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out int OutIndex, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetPhysicalMaterialIndex(DIContext, InWorldPos, OutIndex, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}

	return false;
}
#endif

bool UNiagaraDataInterfaceLandscape::InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	FNDILandscapeData_GameThread* InstanceData = new(PerInstanceData) FNDILandscapeData_GameThread();
	ApplyLandscape(*SystemInstance, *InstanceData);

	FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
	ENQUEUE_RENDER_COMMAND(FNiagaraDICreateProxy) (
		[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
	{
		check(!RT_Proxy->SystemInstancesToProxyData_RT.Contains(InstanceID));
		RT_Proxy->SystemInstancesToProxyData_RT.Add(InstanceID);
	});

	return true;
}

void UNiagaraDataInterfaceLandscape::DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		InstanceData->~FNDILandscapeData_GameThread();

		FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
		ENQUEUE_RENDER_COMMAND(FNiagaraDIDestroyProxy) (
			[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
		{
			RT_Proxy->SystemInstancesToProxyData_RT.Remove(InstanceID);
		});
	}
}

int32 UNiagaraDataInterfaceLandscape::PerInstanceDataSize() const
{
	return sizeof(FNDILandscapeData_GameThread);
}

bool UNiagaraDataInterfaceLandscape::PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds)
{
	bool ResetInstance = false;

	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		// todo - can we avoid checking this every tick?  currently it is required in case the landscape beneath us changes or new data
		// has stremaed in for the landscape and we need to update our capture of the data
		ApplyLandscape(*SystemInstance, *InstanceData);

		if (InstanceData->RequiresCollisionCacheGpu || InstanceData->RequiresPhysMatCacheGpu)
		{
			FNDI_Landscape_GeneratedData& GeneratedData = SystemInstance->GetWorldManager()->EditGeneratedData<FNDI_Landscape_GeneratedData>();
			InstanceData->SharedResourceHandle = GeneratedData.GetLandscapeData(*this, *SystemInstance, *InstanceData, FNDI_SharedResourceUsage(false, true), true);
		}
		else
		{
			InstanceData->SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		}
	}

	return ResetInstance;
}

void UNiagaraDataInterfaceLandscape::ApplyLandscape(const FNiagaraSystemInstance& SystemInstance, FNDILandscapeData_GameThread& InstanceData) const
{
	ALandscape* Landscape = GetLandscape(SystemInstance, InstanceData.Landscape.Get());

	// when in editor the contents of the Landscape are volatile and so we'll make sure to
	// refresh our instance properties any time we apply
	#if !WITH_EDITOR
	if (InstanceData.Landscape == Landscape)
	{
		return;
	}
	#endif

	if (!Landscape)
	{
		InstanceData.Reset();
		return;
	}

	InstanceData.Landscape = Landscape;
	InstanceData.HeightVirtualTextureIndex = INDEX_NONE;
	InstanceData.NormalVirtualTextureIndex = INDEX_NONE;

	// only worry about virtual textures if our current platform supports them
	if (UseVirtualTexturing(SystemInstance.GetFeatureLevel()))
	{
		const int32 RuntimeVirtualTextureCount = InstanceData.Landscape->RuntimeVirtualTextures.Num();
		for (int32 TextureIt = 0; TextureIt < RuntimeVirtualTextureCount; ++TextureIt)
		{
			if (const URuntimeVirtualTexture* Vt = InstanceData.Landscape->RuntimeVirtualTextures[TextureIt])
			{
				const ERuntimeVirtualTextureMaterialType VirtualMaterialType = Vt->GetMaterialType();

				switch (VirtualMaterialType)
				{
				case ERuntimeVirtualTextureMaterialType::WorldHeight:
					if (InstanceData.HeightVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.HeightVirtualTextureIndex = TextureIt;
					}
					break;

				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
					if (InstanceData.NormalVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.NormalVirtualTextureIndex = TextureIt;
						InstanceData.NormalVirtualTextureMode = VirtualMaterialType;
					}
					break;
				}
			}
		}
	}

	bool SystemRequiresHeightsCpu = false;
	bool SystemRequiresHeightsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetHeightName, SystemRequiresHeightsCpu, SystemRequiresHeightsGpu);

	bool SystemRequiresNormalsCpu = false;
	bool SystemRequiresNormalsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetWorldNormalName, SystemRequiresNormalsCpu, SystemRequiresNormalsGpu);

	bool SystemRequiresPhysMatCpu = false;
	bool SystemRequiresPhysMatGpu = false;
	SystemInstance.EvaluateBoundFunction(GetPhysicalMaterialIndexName, SystemRequiresPhysMatCpu, SystemRequiresPhysMatGpu);

	// we need to create our own copy of the collision geometry if either the heights are needed, and they're not
	// provided by a virtual texture or if the normals are needed and they're not provided by a virtual texture
	InstanceData.RequiresCollisionCacheGpu = (SystemRequiresHeightsGpu && InstanceData.HeightVirtualTextureIndex == INDEX_NONE)
		|| (SystemRequiresNormalsGpu && InstanceData.NormalVirtualTextureIndex == INDEX_NONE);

	InstanceData.RequiresPhysMatCacheGpu = SystemRequiresPhysMatGpu;
}


// Users can supply a ALandscape actor
// if none is provided, then we use the World's LandscapeInfoMap to find an appropriate ALandscape actor
ALandscape* UNiagaraDataInterfaceLandscape::GetLandscape(const FNiagaraSystemInstance& SystemInstance, ALandscape* Hint) const
{
	if (ALandscape* Landscape = Cast<ALandscape>(SourceLandscape))
	{
		const bool HasValidSource = Landscape != nullptr;

		if (SourceMode == ENDILandscape_SourceMode::Source || (SourceMode == ENDILandscape_SourceMode::Default && HasValidSource))
		{
			return Landscape;
		}
	}

	const FBox WorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());

	auto TestLandscape = [&](const ALandscape* InLandscape)
	{
		if (InLandscape->GetWorld() == SystemInstance.GetWorld())
		{
			if (const ULandscapeInfo* LandscapeInfo = InLandscape->GetLandscapeInfo())
			{
				for (const auto& ComponentIt : LandscapeInfo->XYtoCollisionComponentMap)
				{
					if (WorldBounds.IntersectXY(ComponentIt.Value->Bounds.GetBox()))
					{
						return true;
					}
				}
			}
		}

		return false;
	};

	if (Hint && TestLandscape(Hint))
	{
		return Hint;
	}

	for (TActorIterator<ALandscape> LandscapeIt(SystemInstance.GetWorld()); LandscapeIt; ++LandscapeIt)
	{
		if (ALandscape* Landscape = *LandscapeIt)
		{
			if (TestLandscape(Landscape))
			{
				return Landscape;
			}
		}
	}

	return nullptr;
}

struct FNiagaraDataInterfaceParametersCS_Landscape : public FNiagaraDataInterfaceParametersCS
{
	DECLARE_TYPE_LAYOUT(FNiagaraDataInterfaceParametersCS_Landscape, NonVirtual);

private:
	enum class ENormalUnpackType : int32
	{
		None = 0,
		BC3BC3,
		BC5BC1,
	};

public:
	void Bind(const FNiagaraDataInterfaceGPUParamInfo& ParameterInfo, const class FShaderParameterMap& ParameterMap)
	{
		HeightVirtualTextureParam.Bind(ParameterMap, *(HeightVirtualTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableParam.Bind(ParameterMap, *(HeightVirtualTexturePageTableName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureSamplerParam.Bind(ParameterMap, *(HeightVirtualTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureWorldToUvTransformParam.Bind(ParameterMap, *(HeightVirtualTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureEnabledParam.Bind(ParameterMap, *(HeightVirtualTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableUniform0Param.Bind(ParameterMap, *(HeightVirtualTexturePageTableUniform0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableUniform1Param.Bind(ParameterMap, *(HeightVirtualTexturePageTableUniform1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureUniformsParam.Bind(ParameterMap, *(HeightVirtualTextureUniformsName + ParameterInfo.DataInterfaceHLSLSymbol));

		NormalVirtualTexture0Param.Bind(ParameterMap, *(NormalVirtualTexture0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexture1Param.Bind(ParameterMap, *(NormalVirtualTexture1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableParam.Bind(ParameterMap, *(NormalVirtualTexturePageTableName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureSamplerParam.Bind(ParameterMap, *(NormalVirtualTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureWorldToUvTransformParam.Bind(ParameterMap, *(NormalVirtualTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureEnabledParam.Bind(ParameterMap, *(NormalVirtualTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUnpackModeParam.Bind(ParameterMap, *(NormalVirtualTextureUnpackModeName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableUniform0Param.Bind(ParameterMap, *(NormalVirtualTexturePageTableUniform0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableUniform1Param.Bind(ParameterMap, *(NormalVirtualTexturePageTableUniform1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUniforms0Param.Bind(ParameterMap, *(NormalVirtualTextureUniforms0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUniforms1Param.Bind(ParameterMap, *(NormalVirtualTextureUniforms1Name + ParameterInfo.DataInterfaceHLSLSymbol));

		CachedHeightTextureParam.Bind(ParameterMap, *(CachedHeightTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureSamplerParam.Bind(ParameterMap, *(CachedHeightTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureWorldToUvTransformParam.Bind(ParameterMap, *(CachedHeightTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureUvToWorldTransformParam.Bind(ParameterMap, *(CachedHeightTextureUvToWorldTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureUvScaleBiasParam.Bind(ParameterMap, *(CachedHeightTextureUvScaleBiasName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTexturEnabledParam.Bind(ParameterMap, *(CachedHeightTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureGridSizeParam.Bind(ParameterMap, *(CachedHeightTextureGridSizeName + ParameterInfo.DataInterfaceHLSLSymbol));
		PointClampedSamplerParam.Bind(ParameterMap, *(PointClampedSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedPhysMatTextureParam.Bind(ParameterMap, *(CachedPhysMatTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedPhysMatTextureDimensionParam.Bind(ParameterMap, *(CachedPhysMatTextureDimensionName + ParameterInfo.DataInterfaceHLSLSymbol));
	}

	bool SetHeightVirtualTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		const IAllocatedVirtualTexture* HeightAllocatedTexture = ProxyData.HeightVirtualTexture
			? ProxyData.HeightVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!HeightAllocatedTexture)
		{
			return false;
		}

		// todo - need to figure out a way to confirm that this is in fact the best/only option for the height
		constexpr uint32 HeightVirtualTextureLayerIndex = 0;
		constexpr uint32 HeightVirtualTexturePageIndex = 0;
		constexpr bool HeightVirtualTextureSrgb = false;

		FRHIShaderResourceView* PhysicalTextureSrv = HeightAllocatedTexture->GetPhysicalTextureSRV(HeightVirtualTextureLayerIndex, HeightVirtualTextureSrgb);
		if (!PhysicalTextureSrv)
		{
			return false;
		}

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = HeightAllocatedTexture->GetPageTableTexture(HeightVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FMatrix WorldToUvTransform(
			FVector(ProxyData.HeightVirtualTextureWorldToUvParameters[0]),
			FVector(ProxyData.HeightVirtualTextureWorldToUvParameters[1]),
			FVector(ProxyData.HeightVirtualTextureWorldToUvParameters[2]),
			FVector(ProxyData.HeightVirtualTextureWorldToUvParameters[3]));

		SetSRVParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureParam, PhysicalTextureSrv);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableParam, PageTableTexture);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureWorldToUvTransformParam, WorldToUvTransform);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureEnabledParam, 1 /* true */);

		FUintVector4 HeightVirtualTexturePageTableUniforms[2];
		FUintVector4 HeightVirtualTextureUniforms;

		HeightAllocatedTexture->GetPackedPageTableUniform(HeightVirtualTexturePageTableUniforms);
		HeightAllocatedTexture->GetPackedUniform(&HeightVirtualTextureUniforms, HeightVirtualTextureLayerIndex);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform0Param, HeightVirtualTexturePageTableUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform1Param, HeightVirtualTexturePageTableUniforms[1]);

		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureUniformsParam, HeightVirtualTextureUniforms);

		return true;
	}

	void SetHeightVirtualTextureParameters_Default(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FUintVector4 DummyUint4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableParam, GBlackTexture->TextureRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureWorldToUvTransformParam, FMatrix::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureEnabledParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform1Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureUniformsParam, DummyUint4);
	}

	bool SetNormalVirtualTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		const IAllocatedVirtualTexture* NormalAllocatedTexture = ProxyData.NormalVirtualTexture
			? ProxyData.NormalVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!NormalAllocatedTexture)
		{
			return false;
		}

		constexpr uint32 NormalVirtualTexturePageIndex = 0;

		FRHIShaderResourceView* PhysicalTextureSrv[2] = { GBlackTextureWithSRV->ShaderResourceViewRHI, GBlackTextureWithSRV->ShaderResourceViewRHI };
		FUintVector4 NormalVirtualTextureUniforms[2];

		switch (ProxyData.NormalVirtualTextureMode)
		{
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(0, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 0);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 1);

				SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::BC3BC3);
				break;

			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 1);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(2, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 2);

				SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::BC5BC1);
				break;

			default:
				return false;
		}

		FMatrix WorldToUvTransform(
			FVector(ProxyData.NormalVirtualTextureWorldToUvParameters[0]),
			FVector(ProxyData.NormalVirtualTextureWorldToUvParameters[1]),
			FVector(ProxyData.NormalVirtualTextureWorldToUvParameters[2]),
			FVector4(0.0f, 0.0f, 0.0f, 1.0f));

		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture0Param, PhysicalTextureSrv[0]);
		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture1Param, PhysicalTextureSrv[1]);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableParam, NormalAllocatedTexture->GetPageTableTexture(NormalVirtualTexturePageIndex));
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureWorldToUvTransformParam, WorldToUvTransform);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureEnabledParam, 1 /* true */);

		FUintVector4 NormalVirtualTexturePageTableUniforms[2];
		NormalAllocatedTexture->GetPackedPageTableUniform(NormalVirtualTexturePageTableUniforms);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform0Param, NormalVirtualTexturePageTableUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform1Param, NormalVirtualTexturePageTableUniforms[1]);

		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms0Param, NormalVirtualTextureUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms1Param, NormalVirtualTextureUniforms[1]);

		return true;
	}

	void SetNormalVirtualTextureParameters_Default(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FUintVector4 DummyUint4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture0Param, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture1Param, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableParam, GBlackTexture->TextureRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureWorldToUvTransformParam, FMatrix::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureEnabledParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::None);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform1Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms1Param, DummyUint4);
	}

	bool SetCachedHeightTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		if (ProxyData.TextureResources)
		{
			FRHIShaderResourceView* HeightTextureSrv = ProxyData.TextureResources->GetHeightTexture();
			FRHIShaderResourceView* PhysMatTextureSrv = ProxyData.TextureResources->GetPhysMatTexture();

			if (HeightTextureSrv || PhysMatTextureSrv)
			{
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureWorldToUvTransformParam, ProxyData.CachedHeightTextureWorldToUvTransform);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvToWorldTransformParam, ProxyData.CachedHeightTextureUvToWorldTransform);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvScaleBiasParam, ProxyData.CachedHeightTextureUvScaleBias);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureGridSizeParam, ProxyData.CachedHeightTextureGridSize);

				if (HeightTextureSrv)
				{
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, HeightTextureSrv);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 1 /* true */);
				}
				else
				{
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 0 /* true */);
				}

				if (PhysMatTextureSrv)
				{
					FIntPoint PhysMatDimensions(ProxyData.TextureResources->GetPhysMatDimensions());
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, PhysMatTextureSrv);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureDimensionParam, PhysMatDimensions);
				}
				else
				{
					FIntPoint PhysMatDimensions(ForceInitToZero);
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureDimensionParam, PhysMatDimensions);
				}

				FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();;
				SetSamplerParameter(RHICmdList, ComputeShaderRHI, PointClampedSamplerParam, PointClampedSampler);

				return true;
			}
		}

		return false;
	}

	void SetCachedHeightTextureParameters_Defaults(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FVector4 DummyVector4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureWorldToUvTransformParam, FMatrix::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvToWorldTransformParam, FMatrix::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvScaleBiasParam, DummyVector4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureGridSizeParam, 0.0f);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 0 /* false */);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);

		FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();;
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, PointClampedSamplerParam, PointClampedSampler);
	}

	void Set(FRHICommandList& RHICmdList, const FNiagaraDataInterfaceSetArgs& Context) const
	{
		check(IsInRenderingThread());

		FRHIComputeShader* ComputeShaderRHI = Context.Shader.GetComputeShader();

		FNiagaraDataInterfaceProxyLandscape* RT_Proxy = static_cast<FNiagaraDataInterfaceProxyLandscape*>(Context.DataInterface);
		FNDILandscapeData_RenderThread* ProxyData = RT_Proxy ? RT_Proxy->SystemInstancesToProxyData_RT.Find(Context.SystemInstanceID) : nullptr;

		// global samplers
		FRHISamplerState* BilinearSamplerState = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureSamplerParam, BilinearSamplerState);
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTextureSamplerParam, BilinearSamplerState);
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureSamplerParam, BilinearSamplerState);

		bool ApplyHeightVirtualTextureDefaults = true;
		bool ApplyNormalVirtualTextureDefaults = true;
		bool ApplyCachedHeightTextureDefaults = true;

		if (ProxyData)
		{
			if (SetHeightVirtualTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyHeightVirtualTextureDefaults = false;
			}

			if (SetNormalVirtualTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyNormalVirtualTextureDefaults = false;
			}

			if (SetCachedHeightTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyCachedHeightTextureDefaults = false;
			}
		}

		if (ApplyHeightVirtualTextureDefaults)
		{
			SetHeightVirtualTextureParameters_Default(RHICmdList, ComputeShaderRHI);
		}

		if (ApplyNormalVirtualTextureDefaults)
		{
			SetNormalVirtualTextureParameters_Default(RHICmdList, ComputeShaderRHI);
		}

		if (ApplyCachedHeightTextureDefaults)
		{
			SetCachedHeightTextureParameters_Defaults(RHICmdList, ComputeShaderRHI);
		}
	}

private:
	// virtual texture parameters - height
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTextureParam);
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTexturePageTableParam);
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureEnabledParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTexturePageTableUniform0Param);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTexturePageTableUniform1Param);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureUniformsParam);

	// virtual texture parameters - normal
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexture0Param);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexture1Param);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexturePageTableParam);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureEnabledParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUnpackModeParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTexturePageTableUniform0Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTexturePageTableUniform1Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUniforms0Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUniforms1Param);

	// cached texture parameters - height
	LAYOUT_FIELD(FShaderResourceParameter, CachedHeightTextureParam);
	LAYOUT_FIELD(FShaderResourceParameter, CachedHeightTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureUvToWorldTransformParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureUvScaleBiasParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTexturEnabledParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureGridSizeParam);
	LAYOUT_FIELD(FShaderResourceParameter, PointClampedSamplerParam);

	// cached texture parameters - phys mat
	LAYOUT_FIELD(FShaderResourceParameter, CachedPhysMatTextureParam);
	LAYOUT_FIELD(FShaderParameter, CachedPhysMatTextureDimensionParam);

	static const FString HeightVirtualTextureEnabledName;
	static const FString HeightVirtualTextureName;
	static const FString HeightVirtualTexturePageTableName;
	static const FString HeightVirtualTexturePageTableUniform0Name;
	static const FString HeightVirtualTexturePageTableUniform1Name;
	static const FString HeightVirtualTextureSamplerName;
	static const FString HeightVirtualTextureUniformsName;
	static const FString HeightVirtualTextureWorldToUvTransformName;

	static const FString NormalVirtualTexture0Name;
	static const FString NormalVirtualTexture1Name;
	static const FString NormalVirtualTexturePageTableName;
	static const FString NormalVirtualTextureSamplerName;
	static const FString NormalVirtualTextureWorldToUvTransformName;
	static const FString NormalVirtualTextureEnabledName;
	static const FString NormalVirtualTextureUnpackModeName;
	static const FString NormalVirtualTexturePageTableUniform0Name;
	static const FString NormalVirtualTexturePageTableUniform1Name;
	static const FString NormalVirtualTextureUniforms0Name;
	static const FString NormalVirtualTextureUniforms1Name;

	static const FString CachedHeightTextureEnabledName;
	static const FString CachedHeightTextureName;
	static const FString CachedHeightTextureSamplerName;
	static const FString CachedHeightTextureUvScaleBiasName;
	static const FString CachedHeightTextureWorldToUvTransformName;
	static const FString CachedHeightTextureUvToWorldTransformName;
	static const FString CachedHeightTextureGridSizeName;
	static const FString PointClampedSamplerName;
	static const FString CachedPhysMatTextureName;
	static const FString CachedPhysMatTextureDimensionName;
};

// virtual texture parameters - height
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureEnabledName(TEXT("HeightVirtualTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureName(TEXT("HeightVirtualTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableName(TEXT("HeightVirtualTexturePageTable_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableUniform0Name(TEXT("HeightVirtualTexturePackedUniform0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableUniform1Name(TEXT("HeightVirtualTexturePackedUniform1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureSamplerName(TEXT("HeightVirtualTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureUniformsName(TEXT("HeightVirtualTextureUniforms_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureWorldToUvTransformName(TEXT("HeightVirtualTextureWorldToUvTransform_"));

// virtual texture parameters - normal
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexture0Name(TEXT("NormalVirtualTexture0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexture1Name(TEXT("NormalVirtualTexture1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableName(TEXT("NormalVirtualTexturePageTable_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureSamplerName(TEXT("NormalVirtualTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureWorldToUvTransformName(TEXT("NormalVirtualTextureWorldToUvTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureEnabledName(TEXT("NormalVirtualTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUnpackModeName(TEXT("NormalVirtualTextureUnpackMode_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableUniform0Name(TEXT("NormalVirtualTexturePackedUniform0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableUniform1Name(TEXT("NormalVirtualTexturePackedUniform1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUniforms0Name(TEXT("NormalVirtualTextureUniforms0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUniforms1Name(TEXT("NormalVirtualTextureUniforms1_"));

// cached texture - height
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureEnabledName(TEXT("CachedHeightTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureName(TEXT("CachedHeightTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureSamplerName(TEXT("CachedHeightTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureUvScaleBiasName(TEXT("CachedHeightTextureUvScaleBias_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureWorldToUvTransformName(TEXT("CachedHeightTextureWorldToUvTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureUvToWorldTransformName(TEXT("CachedHeightTextureUvToWorldTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureGridSizeName(TEXT("CachedHeightTextureGridSize_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::PointClampedSamplerName(TEXT("PointClampedSampler_"));

// cached texture - physmat
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedPhysMatTextureName(TEXT("CachedPhysMatTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedPhysMatTextureDimensionName(TEXT("CachedPhysMatTextureDimension_"));

IMPLEMENT_TYPE_LAYOUT(FNiagaraDataInterfaceParametersCS_Landscape);
IMPLEMENT_NIAGARA_DI_PARAMETER(UNiagaraDataInterfaceLandscape, FNiagaraDataInterfaceParametersCS_Landscape);

#undef LOCTEXT_NAMESPACE