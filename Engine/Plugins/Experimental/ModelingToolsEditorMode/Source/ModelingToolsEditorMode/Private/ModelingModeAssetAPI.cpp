// Copyright Epic Games, Inc. All Rights Reserved.

#include "ModelingModeAssetAPI.h"
#include "ModelingToolsEditorModeSettings.h"
#include "MeshDescription.h"
#include "Engine/Classes/Engine/Texture2D.h"
#include "Misc/Guid.h"

#include "ModelingObjectsCreationAPI.h"
#include "Editor/EditorEngine.h"
#include "EditorDirectories.h"
#include "Misc/Paths.h"
#include "Misc/PackageName.h"

#include "AssetRegistryModule.h"
#include "AssetToolsModule.h"
#include "FileHelpers.h"

#include "ContentBrowserModule.h"

#include "IContentBrowserSingleton.h"
#include "StaticMeshComponentBuilder.h"



#define LOCTEXT_NAMESPACE "FModelingModeAssetAPI"

namespace UE
{
	namespace Local
	{

		FString GetActiveAssetFolderPath()
		{
			IContentBrowserSingleton& ContentBrowser = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser").Get();
			return ContentBrowser.GetCurrentPath();
		}


		FString MakeUniqueAssetName(const FString& FolderPath, const FString& AssetBaseName)
		{
			FString UniquePackageName, UniqueAssetName;
			FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools");
			AssetToolsModule.Get().CreateUniqueAssetName(
				FolderPath + TEXT("/") + AssetBaseName, TEXT(""), UniquePackageName, UniqueAssetName);
			return UniqueAssetName;
		}


		FString InteractiveSelectAssetPath(const FString& DefaultAssetName, const FText& DialogTitleMessage)
		{
			IContentBrowserSingleton& ContentBrowser = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser").Get();

			FString UseDefaultAssetName = DefaultAssetName;
			FString CurrentPath = GetActiveAssetFolderPath();
			if (CurrentPath.IsEmpty() == false)
			{
				UseDefaultAssetName = MakeUniqueAssetName(CurrentPath, DefaultAssetName);
			}

			FSaveAssetDialogConfig Config;
			Config.DefaultAssetName = UseDefaultAssetName;
			Config.DialogTitleOverride = DialogTitleMessage;
			Config.DefaultPath = CurrentPath;
			return ContentBrowser.CreateModalSaveAssetDialog(Config);
		}


		// Replaces each non-alphanumeric character with an underscore.
		void SanitizeObjectNameToAlphaNumeric(FString& ObjectName)
		{
			for (TCHAR& Character : ObjectName)
			{
				if (!FChar::IsAlnum(Character))
				{
					Character = TEXT('_');
				}
			}
		}


	}
}


/**
 * Generate a N-letter GUID string that contains only hex digits,
 * and contains at least one letter and one number
 */
static FString GenerateAssetRandomGUID(int32 NumChars = 8)
{
	int32 FailCount = 0;
	while (FailCount++ < 10)
	{
		FGuid Guid = FGuid::NewGuid();
		FString GuidString = Guid.ToString(EGuidFormats::UniqueObjectGuid).ToUpper();
		FString Result;
		int32 Digits = 0, Letters = 0;
		for (int32 k = 0; k < GuidString.Len(); ++k)
		{
			TCHAR Character = GuidString[k];
			if (FChar::IsHexDigit(Character))
			{
				Result.AppendChar(Character);
				if (FChar::IsDigit(Character))
				{
					Digits++;
				}
				else
				{
					Letters++;
				}
			}
			if (Result.Len() == NumChars)
			{
				if (Digits > 0 && Letters > 0)
				{
					return Result;
				}
				break;		// exit loop
			}
		}
	}
	return TEXT("BADGUID1");
}





bool FModelingModeAssetAPI::GetNewActorPackagePath(
	UWorld* TargetWorld,
	FString ObjectBaseName,
	const FGeneratedStaticMeshAssetConfig& AssetConfig,
	FString& PackageFolderPathOut,
	FString& ObjectBaseNameOut )
{
	check(TargetWorld);
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;

	// figure out the appropriate root path to use
	FString PackageFolderPath = TEXT("/Game/");
	if (Settings->AssetGenerationLocation == EModelingModeAssetGenerationLocation::AutoGeneratedWorldRelativeAssetPath)
	{
		PackageFolderPath = GetWorldRelativeAssetRootPath(TargetWorld);
	}

	// If the level is unsaved, then GetWorldRelativeAssetRootPath will return "/Temp". This is an undesirable
	// place to even temporarily save assets because they must be manually moved elsewhere to save, and the /Temp folder 
	// is somewhat troublesome to get to in the Editor. So if the flag below is set, then we will fall back to /Game
	// instead. Projects with strict asset polices (due to P4/etc) may not want to allow this by default, so it is configurable.
	if (PackageFolderPath.StartsWith("/Temp") && Settings->bStoreUnsavedLevelAssetsInTopLevelGameFolder)
	{
		PackageFolderPath = TEXT("/Game/");
	}

	// combine with fixed AutoGen path name if it is not empty
	if (Settings->AutoGeneratedAssetPath.Len() > 0)
	{
		PackageFolderPath = FPaths::Combine(PackageFolderPath, Settings->AutoGeneratedAssetPath);
	}

	// append username-specific subfolder
	if (Settings->bUsePerUserAutogenSubfolder)
	{
		FString UsernameString(FPlatformProcess::UserName());
		if (UsernameString.Len() > 1)
		{
			PackageFolderPath = FPaths::Combine(PackageFolderPath, UsernameString);
		}
	}

	// if we want to use the currently-visible asset browser path, try to find one (this can fail if no asset browser is visible/etc)
	if (Settings->AssetGenerationLocation == EModelingModeAssetGenerationLocation::CurrentAssetBrowserPathIfAvailable)
	{
		FString CurrentAssetPath = GetActiveAssetFolderPath();
		if (CurrentAssetPath.IsEmpty() == false)
		{
			PackageFolderPath = CurrentAssetPath;
		}
	}

	// If we are in interactive mode, show the modal dialog and then get the path/name.
	// If the user cancels, we are going to discard the asset
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		FString SelectedPath = InteractiveSelectAssetPath(ObjectBaseName, LOCTEXT("GenerateStaticMeshActorPathDialogWarning", "Choose Folder Path and Name for New Asset. Cancel to Discard New Asset."));
		if (SelectedPath.IsEmpty() == false)
		{
			PackageFolderPath = FPaths::GetPath(SelectedPath);
			ObjectBaseName = FPaths::GetBaseFilename(SelectedPath, true);
		}
		else
		{
			return false;
		}
	}

	FString UseBaseName = ObjectBaseName;
	if (Settings->bAppendRandomStringToName)
	{
		FString GuidString = GenerateAssetRandomGUID();
		UseBaseName = FString::Printf(TEXT("%s_%s"), *UseBaseName, *GuidString);
	}

	PackageFolderPathOut = PackageFolderPath;
	ObjectBaseNameOut = UseBaseName;
	return true;
}





AActor* FModelingModeAssetAPI::GenerateStaticMeshActor(
	UWorld* TargetWorld,
	FTransform Transform,
	FString ObjectBaseName,
	FGeneratedStaticMeshAssetConfig&& AssetConfig)
{
	check(TargetWorld);
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;

	FString UsePackageFolderPath;
	FString UseBaseName;
	bool bContinue = GetNewActorPackagePath(TargetWorld, ObjectBaseName, AssetConfig, UsePackageFolderPath, UseBaseName);
	if (!bContinue)
	{
		return nullptr;
	}

	// create new package with unique local name
	FString UniqueAssetName;
	UPackage* AssetPackage = MakeNewAssetPackage(UsePackageFolderPath, UseBaseName, UniqueAssetName);

	// create new actor
	FRotator Rotation(0.0f, 0.0f, 0.0f);
	FActorSpawnParameters SpawnInfo;
	// @todo nothing here is specific to AStaticMeshActor...could we pass in a CDO and clone it instead of using SpawnActor?
	AStaticMeshActor* NewActor = TargetWorld->SpawnActor<AStaticMeshActor>(FVector::ZeroVector, Rotation, SpawnInfo);
	NewActor->SetActorLabel(*UniqueAssetName);

	// construct new static mesh
	FStaticMeshComponentBuilder Builder;
	Builder.Initialize(AssetPackage, FName(*UniqueAssetName), AssetConfig.Materials.Num());

	if (AssetConfig.MeshDescription.IsValid())
	{
		*Builder.MeshDescription = *AssetConfig.MeshDescription;
	}
	else
	{
		// should generate default sphere here or something...
	}

	// create new mesh component and set as root of NewActor.
	Builder.CreateAndSetAsRootComponent(NewActor);

	// configure transform and materials of new component
	Builder.NewMeshComponent->SetWorldTransform((FTransform)Transform);
	for (int MatIdx = 0, NumMats = AssetConfig.Materials.Num(); MatIdx < NumMats; MatIdx++)
	{
		Builder.NewMeshComponent->SetMaterial(MatIdx, AssetConfig.Materials[MatIdx]);
	}

	// save the new asset (or don't, if that's what the user wants)
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateAndAutosave )
	{ 
		AutoSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		AutoSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
		// this spawns a dialog that just allows save or not-save, but not renaming/etc, seems kind of useless...
		//InteractiveSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateButDoNotAutosave)
	{
		NotifyGeneratedAssetModified(Builder.NewStaticMesh, AssetPackage);
	}

	return NewActor;
}










bool FModelingModeAssetAPI::SaveGeneratedTexture2D(
	UTexture2D* GeneratedTexture,
	FString ObjectBaseName,
	const UObject* RelativeToAsset)
{
	check(RelativeToAsset);
	check(GeneratedTexture);
	check(GeneratedTexture->GetOuter() == GetTransientPackage());
	check(GeneratedTexture->Source.IsValid());	// texture needs to have valid source data to be savd
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;

	// find path to asset
	UPackage* AssetOuterPackage = CastChecked<UPackage>(RelativeToAsset->GetOuter());
	FString AssetPackageName = AssetOuterPackage->GetName();
	FString AssetPackageFolder = FPackageName::GetLongPackagePath(AssetPackageName);

	FString PackageFolderPath = AssetPackageFolder;

	// If we are in interactive mode, show the modal dialog and then get the path/name.
	// If the user cancels, we are going to discard the asset
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		FString SelectedPath = InteractiveSelectAssetPath(ObjectBaseName, LOCTEXT("GenerateTexture2DAssetPathDialogWarning", "Choose Folder Path and Name for New Asset. Cancel to Discard New Asset."));
		if (SelectedPath.IsEmpty() == false)
		{
			PackageFolderPath = FPaths::GetPath(SelectedPath);
			ObjectBaseName = FPaths::GetBaseFilename(SelectedPath, true);
		}
		else
		{
			return false;
		}
	}

	// mangle the name
	FString UseBaseName = ObjectBaseName;
	if (Settings->bAppendRandomStringToName)
	{
		FString GuidString = GenerateAssetRandomGUID();
		UseBaseName = FString::Printf(TEXT("%s_%s"), *UseBaseName, *GuidString);
	}

	// create new package
	FString UniqueAssetName;
	UPackage* AssetPackage = MakeNewAssetPackage(PackageFolderPath, UseBaseName, UniqueAssetName);

	// move texture from Transient package to real package
	GeneratedTexture->Rename( *UniqueAssetName, AssetPackage, REN_None);
	// remove transient flag, add public/standalone/transactional
	GeneratedTexture->ClearFlags(RF_Transient);
	GeneratedTexture->SetFlags(RF_Public | RF_Standalone | RF_Transactional);
	// do we need to Modify() it? we are not doing any undo/redo
	GeneratedTexture->Modify();
	GeneratedTexture->UpdateResource();
	GeneratedTexture->PostEditChange();		// this may be necessary if any Materials are using this texture
	GeneratedTexture->MarkPackageDirty();


	// save the new asset (or don't, if that's what the user wants)
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateAndAutosave)
	{
		AutoSaveGeneratedAsset(GeneratedTexture, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		AutoSaveGeneratedAsset(GeneratedTexture, AssetPackage);
		// this spawns a dialog that just allows save or not-save, but not renaming/etc, seems kind of useless...
		//InteractiveSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateButDoNotAutosave)
	{
		NotifyGeneratedAssetModified(GeneratedTexture, AssetPackage);
	}

	return true;
}

FString UE::Modeling::GetWorldRelativeAssetRootPath(const UWorld* World)
{
	if (World == nullptr)
	{
		World = GEditor->bIsSimulatingInEditor ? GEditor->GetPIEWorldContext()->World() : GEditor->GetEditorWorldContext().World();
	}

	if (ensure(World->GetPackage() != nullptr) == false)
	{
		return GetGlobalAssetRootPath();
	}

	const FString WorldPackageName = World->GetPackage()->GetName();
	const FString WorldPackageFolder = FPackageName::GetLongPackagePath(WorldPackageName);
	return WorldPackageFolder;
}

FString UE::Modeling::GetGlobalAssetRootPath()
{
	// There currently is no mechanism to explicitly get the root content folder.
	// The effectively best way to do this is to request the "last directory" for an invalid identifier, which falls back to the root content folder. 

	const FString RootFilePath = FEditorDirectories::Get().GetLastDirectory(ELastDirectory::MAX);
	FString RootRelativePath;
	FString FailureReason;
	if (FPackageName::TryConvertFilenameToLongPackageName(RootFilePath, RootRelativePath, &FailureReason))
	{
		return RootRelativePath;
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("Could not create global asset root path. Faiure Reason: %s"), *FailureReason);
		return {};
	}
}

FString UE::Modeling::GetNewAssetPathName(const FString& BaseNameIn, const UWorld* TargetWorld, FString SuggestedFolder)
{
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	const EModelingModeAssetGenerationBehavior AutoGenMode = Settings->GetAssetGenerationMode();

	FString PackageFolderPath = GetGlobalAssetRootPath();
	bool bFallBackToInteractiveSave = false;

	if (SuggestedFolder.Len() > 0 && SuggestedFolder.StartsWith("/"))
	{
		// if we had a suggested folder, use it (todo: check that this folder exists? or can be created?)
		PackageFolderPath = SuggestedFolder;
	}
	else
	{
		// Figure out the appropriate package path to use. If the level is in a plugin, this should be the plugin top-level path.
		if (Settings->GetAssetGenerationLocation() == EModelingModeAssetGenerationLocation::AutoGeneratedWorldRelativeAssetPath)
		{
			PackageFolderPath = GetWorldRelativeAssetRootPath(TargetWorld);
		}

		// If the level is unsaved, then GetWorldRelativeAssetRootPath will return "/Temp". This is an undesirable
		// place to even temporarily save assets because they must be manually moved elsewhere to save, and the /Temp folder 
		// is somewhat troublesome to get to in the Editor.
		if (PackageFolderPath.StartsWith("/Temp"))
		{
			if (Settings->InRestrictiveMode())
			{
				// Fall back to the interactively choosing the asset path.
				bFallBackToInteractiveSave = true;
			}
			else
			{
				// If the flag below is set, then we will fall back to the global path instead.
				// Projects with strict asset polices (due to P4/etc) may not want to allow this by default, so it is configurable.
				if (Settings->bStoreUnsavedLevelAssetsInTopLevelGameFolder)
				{
					PackageFolderPath = GetGlobalAssetRootPath();
				}
			}
		}

		if (Settings->InRestrictiveMode())
		{
			// combine with fixed AutoGen path name if it is not empty
			const FString RestrictiveModeAutogenAssetPath = Settings->GetRestrictiveModeAutoGeneratedAssetPath();
			if (RestrictiveModeAutogenAssetPath.Len() > 0)
			{
				PackageFolderPath = FPaths::Combine(PackageFolderPath, RestrictiveModeAutogenAssetPath);
			}
		}
		else
		{
			// combine with fixed AutoGen path name if it is not empty
			if (Settings->AutoGeneratedAssetPath.Len() > 0)
			{
				PackageFolderPath = FPaths::Combine(PackageFolderPath, Settings->AutoGeneratedAssetPath);
			}

			// append username-specific subfolder
			if (Settings->bUsePerUserAutogenSubfolder)
			{
				FString UsernameString = Settings->AutogenSubfolderUserNameOverride.TrimStartAndEnd();
				if (UsernameString.IsEmpty())
				{
					UsernameString = FPlatformProcess::UserName();
				}
				if (!UsernameString.IsEmpty())
				{
					PackageFolderPath = FPaths::Combine(PackageFolderPath, UsernameString);
				}
			}
		}

		// if we want to use the currently-visible asset browser path, try to find one (this can fail if no asset browser is visible/etc)
		if (Settings->GetAssetGenerationLocation() == EModelingModeAssetGenerationLocation::CurrentAssetBrowserPathIfAvailable)
		{
			FString CurrentAssetPath = UE::Local::GetActiveAssetFolderPath();
			if (CurrentAssetPath.IsEmpty() == false)
			{
				PackageFolderPath = CurrentAssetPath;
			}
		}
	}

	FString ObjectBaseName = BaseNameIn;

	// If we are in interactive mode, show the modal dialog and then get the path/name.
	// If the user cancels, we are going to discard the asset
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave || bFallBackToInteractiveSave)
	{
		const FString SelectedPath = UE::Local::InteractiveSelectAssetPath(
			ObjectBaseName, LOCTEXT("GenerateStaticMeshActorPathDialogWarning", "Choose Folder Path and Name for New Asset. Cancel to Discard New Asset."));
		if (SelectedPath.IsEmpty() == false)
		{
			PackageFolderPath = FPaths::GetPath(SelectedPath);
			ObjectBaseName = FPaths::GetBaseFilename(SelectedPath, true);
		}
		else
		{
			return FString();
		}
	}

	FString UseBaseName = ObjectBaseName;

	if (Settings->InRestrictiveMode())
	{
		Local::SanitizeObjectNameToAlphaNumeric(UseBaseName);
	}

	if (Settings->bAppendRandomStringToName)
	{
		FString GuidString = UE::Modeling::GenerateRandomShortHexString();
		UseBaseName = FString::Printf(TEXT("%s_%s"), *UseBaseName, *GuidString);
	}


	FString PackageNameOut, AssetNameOut;
	FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools");
	AssetToolsModule.Get().CreateUniqueAssetName(
		FPaths::Combine(PackageFolderPath, UseBaseName), TEXT(""),
		PackageNameOut, AssetNameOut);

	return PackageNameOut;
}

#undef LOCTEXT_NAMESPACE